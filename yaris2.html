<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>E≈ü Anlamlƒ± Kelimeler Oyunu</title>
  <style>
    html { height: 100%; }
    body {
      box-sizing: border-box;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100%;
      color: white;
    }
    * { box-sizing: border-box; }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 20px;
      padding: 30px;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }
    .header { text-align: center; margin-bottom: 20px; }
    .title {
      font-size: 2.5rem;
      font-weight: bold;
      margin: 0 0 10px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }
    .subtitle {
      font-size: 1.1rem;
      opacity: 0.95;
      margin: 0;
    }

    .card {
      background: rgba(255, 255, 255, 0.15);
      border-radius: 15px;
      padding: 22px;
      margin-bottom: 18px;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      justify-content: center;
      align-items: center;
    }

    .mode-btn {
      padding: 12px 18px;
      border: none;
      border-radius: 25px;
      background: rgba(255, 255, 255, 0.2);
      color: white;
      font-size: 1rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s ease;
      border: 2px solid transparent;
      min-width: 150px;
    }
    .mode-btn:hover { background: rgba(255,255,255,0.3); transform: translateY(-1px); }
    .mode-btn.selected {
      background: #4CAF50;
      border-color: #45a049;
      box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
    }

    .input {
      width: min(360px, 92vw);
      padding: 12px 14px;
      border-radius: 12px;
      border: none;
      outline: none;
      font-size: 1rem;
    }
    .input::placeholder { color: #777; }

    .btn {
      background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
      color: white;
      border: none;
      padding: 14px 28px;
      font-size: 1.1rem;
      font-weight: 800;
      border-radius: 30px;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }
    .btn:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3); }
    .btn.secondary {
      background: rgba(255, 255, 255, 0.18);
      box-shadow: none;
      border: 2px solid rgba(255, 255, 255, 0.25);
      font-weight: 700;
    }
    .btn.secondary:hover {
      background: rgba(255, 255, 255, 0.26);
      transform: translateY(-1px);
    }

    .hint {
      text-align: center;
      margin-top: 10px;
      opacity: 0.95;
      line-height: 1.4;
    }

    /* Game */
    .timer-section { text-align: center; margin-bottom: 18px; }
    .timer {
      font-size: 3rem;
      font-weight: 900;
      color: #FFD700;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      margin-bottom: 10px;
    }
    .progress-container {
      background: rgba(255, 255, 255, 0.2);
      border-radius: 25px;
      height: 18px;
      margin: 0 auto;
      max-width: 800px;
      overflow: hidden;
      display: flex;
    }
    .progress-segment { height: 100%; transition: all 0.4s ease; }
    .progress-segment:first-child { border-radius: 25px 0 0 25px; }
    .progress-segment:last-child { border-radius: 0 25px 25px 0; }
    .progress-segment.single { border-radius: 25px; }

    .contestants-area { display: grid; gap: 18px; margin-top: 8px; }
    .contestants-area.two-columns { grid-template-columns: repeat(2, 1fr); }
    .contestants-area.one-column { grid-template-columns: 1fr; max-width: 760px; margin: 8px auto 0; }
    .contestant {
      background: rgba(255, 255, 255, 0.15);
      border-radius: 15px;
      padding: 18px;
      text-align: center;
      border: 3px solid transparent;
      transition: all 0.2s ease;
    }
    .contestant.player1 { border-color: #FF8C00; }
    .contestant.player2 { border-color: #1E90FF; }
    .contestant-name {
      font-size: 1.25rem;
      font-weight: 900;
      margin-bottom: 10px;
      color: #FFD700;
      word-break: break-word;
    }
    .score {
      font-size: 2.1rem;
      font-weight: 900;
      margin-bottom: 14px;
    }

    .question-area {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 16px;
    }
    .question {
      font-size: 1.7rem;
      font-weight: 900;
      margin-bottom: 12px;
      color: #FF4444;
      letter-spacing: 0.3px;
    }

    .options { display: flex; flex-direction: column; gap: 10px; }
    .option-btn {
      padding: 12px 14px;
      border: none;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.92);
      color: #333;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.2s ease;
      border: 2px solid transparent;
      font-weight: 700;
    }
    .option-btn:hover { background: rgba(255,255,255,1); transform: translateY(-1px); }
    .option-btn.correct { background: #4CAF50; border-color: #45a049; color: white; }
    .option-btn.wrong { background: #f44336; border-color: #da190b; color: white; }

    /* Result */
    .result-hero {
      text-align: center;
      padding: 26px;
      border-radius: 18px;
      background: linear-gradient(45deg, rgba(255, 215, 0, 0.95), rgba(255, 165, 0, 0.95));
      color: #333;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    .result-hero h2 {
      margin: 0 0 8px;
      font-size: 2.2rem;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.15);
    }
    .result-hero .big {
      font-size: 3.1rem;
      font-weight: 900;
      margin: 10px 0 6px;
    }
    .result-hero .mini {
      font-size: 1.05rem;
      opacity: 0.9;
      margin: 0;
    }
    .result-grid {
      display: grid;
      gap: 14px;
      margin-top: 16px;
    }
    .result-grid.two-columns { grid-template-columns: repeat(2, 1fr); }
    .result-card {
      background: rgba(0,0,0,0.18);
      border-radius: 15px;
      padding: 16px;
      text-align: center;
      border: 2px solid rgba(255,255,255,0.18);
    }
    .result-card .name { font-weight: 900; color: #FFD700; }
    .result-card .pts { font-size: 2.2rem; font-weight: 900; margin-top: 6px; }

    /* Records */
    .table-wrap { overflow-x: auto; }
    table {
      width: 100%;
      border-collapse: collapse;
      background: rgba(0,0,0,0.18);
      border-radius: 14px;
      overflow: hidden;
    }
    th, td {
      padding: 10px 12px;
      text-align: left;
      border-bottom: 1px solid rgba(255,255,255,0.12);
    }
    th { color: #FFD700; font-weight: 900; }
    tr:last-child td { border-bottom: none; }

    .badge {
      display: inline-block;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.18);
      font-weight: 800;
    }

    .hidden { display: none !important; }

    @media (max-width: 900px) {
      .contestants-area.two-columns { grid-template-columns: 1fr; }
      .result-grid.two-columns { grid-template-columns: 1fr; }
      .title { font-size: 2rem; }
      body { padding: 14px; }
      .container { padding: 20px; }
      .question { font-size: 1.55rem; }
    }
  @media (max-width:768px){
      .container{padding:16px}
      .title{font-size:2rem}
      .setup-section{padding:16px}
      .timer-section{margin-bottom:12px}
      .timer{font-size:2.2rem;margin-bottom:10px}
      .progress-container{height:14px;margin-bottom:12px}
      .contestants-area{gap:14px}
      .contestants-area.three-columns{grid-template-columns:1fr}
      /* Dikey telefonda 2 ki≈üi tek s√ºtuna d√º≈üebilir */
      .contestants-area.two-columns{grid-template-columns:1fr}
      .contestants-area.one-column{max-width:100%;margin:0 0 20px}
      .contestant{padding:14px}
      .contestant-name{font-size:1.1rem;margin-bottom:10px}
      .score{font-size:1.6rem;margin-bottom:12px}
      .question-area{padding:12px;margin-bottom:12px}
      .question{font-size:1.2rem;margin-bottom:10px}
      .option-btn{padding:10px 12px;font-size:1rem}
    }

    /* Yatay telefonda 2 ki≈üi mutlaka yan yana kalsƒ±n */
    @media (max-width:900px) and (orientation: landscape){
      .container{padding:14px}
      .timer-section{margin-bottom:10px}
      .timer{font-size:2.0rem;margin-bottom:8px}
      .progress-container{height:12px;margin-bottom:10px}
      .contestants-area{gap:12px}
      .contestants-area.two-columns{grid-template-columns:repeat(2,minmax(0,1fr))}
      .contestant{padding:12px}
      .contestant-name{font-size:1.05rem;margin-bottom:8px}
      .score{font-size:1.35rem;margin-bottom:10px}
      .question-area{padding:10px;margin-bottom:10px}
      .question{font-size:1.05rem;margin-bottom:8px}
      .option-btn{padding:8px 10px;font-size:.95rem}
    }

    /* Ekran y√ºksekliƒüi √ßok d√º≈ü√ºkse (yatay telefon gibi) biraz daha sƒ±kƒ±≈ütƒ±r */
    @media (max-height:500px){
      .title{font-size:1.8rem}
      .round-info{font-size:1rem;padding:8px 12px}
      .timer{font-size:1.9rem}
      .progress-container{height:12px;margin-bottom:10px}
      .contestants-area{gap:10px}
      .contestant{padding:11px}
      .score{font-size:1.25rem;margin-bottom:8px}
      .question-area{padding:9px;margin-bottom:9px}
      .question{font-size:1.0rem;margin-bottom:7px}
      .option-btn{padding:7px 9px;font-size:.92rem}
    }
</style>
</head>
<body>
  <main class="container">
    <header class="header">
      <h1 class="title">üéØ E≈ü Anlamlƒ± Kelimeler Oyunu</h1>
      <p class="subtitle" id="headerSubtitle">Modunu se√ß, isim(ler)i yaz ve yarƒ±≈üa ba≈üla!</p>
    </header>

    <!-- HOME -->
    <section class="card" id="homeSection">
      <div class="row" style="margin-bottom: 12px;">
        <button class="mode-btn selected" id="modeSingleBtn">üë§ Tek Ki≈üi</button>
        <button class="mode-btn" id="modeDuelBtn">üë• ƒ∞ki Ki≈üi</button>
      </div>

      <div class="row" id="singleInputsRow">
        <input class="input" id="singleName" placeholder="ƒ∞smini yaz (√∂r: Ay≈üe)" maxlength="24" />
      </div>

      <div class="row hidden" id="duelInputsRow">
        <input class="input" id="duelName1" placeholder="1. Oyuncu (√∂r: Ay≈üe)" maxlength="24" />
        <input class="input" id="duelName2" placeholder="2. Oyuncu (√∂r: Eren)" maxlength="24" />
      </div>

      <div class="row" style="margin-top: 14px;">
        <button class="btn" id="startGameBtn">Yarƒ±≈üƒ± Ba≈ülat</button>
        <button class="btn secondary" id="openRecordsBtn">Rekorlar</button>
      </div>

      <p class="hint">
        ‚è±Ô∏è S√ºre: <span class="badge">60 saniye</span> &nbsp; ‚Ä¢ &nbsp;
        ‚úÖ Doƒüru: <span class="badge">+10</span> &nbsp; ‚Ä¢ &nbsp;
        ‚ùå Yanlƒ±≈ü: <span class="badge">-5</span> + <span class="badge">-3 sn</span>
      </p>
    </section>

    <!-- GAME -->
    <section class="hidden" id="gameSection">
      <div class="timer-section">
        <div class="timer" id="timer">60</div>
        <div class="progress-container" id="progressContainer"></div>
      </div>

      <div class="row" style="margin-bottom: 12px;">
        <button class="btn secondary" id="backToMenuBtn">Ana Men√º</button>
        <button class="btn secondary" id="openRecordsBtn2">Rekorlar</button>
      </div>

      <div class="contestants-area one-column" id="contestantsArea"></div>
    </section>

    <!-- RESULT -->
    <section class="hidden" id="resultSection">
      <div class="result-hero" id="resultHero">
        <div style="font-size: 3.2rem; line-height: 1;">üèÅ</div>
        <h2>Yarƒ±≈ü Bitti!</h2>
        <div class="big" id="resultMainScore">0</div>
        <p class="mini" id="resultMini">Tebrikler!</p>
      </div>

      <div class="result-grid" id="resultGrid"></div>

      <div class="row" style="margin-top: 16px;">
        <button class="btn" id="playAgainBtn">Tekrar Oyna</button>
        <button class="btn secondary" id="menuBtnFromResult">Ana Men√º</button>
        <button class="btn secondary" id="recordsBtnFromResult">Rekorlar</button>
      </div>
    </section>

    <!-- RECORDS -->
    <section class="card hidden" id="recordsSection">
      <div class="row" style="justify-content: space-between; margin-bottom: 10px;">
        <h2 style="margin:0; color:#FFD700;">üèÜ Rekorlar</h2>
        <button class="btn secondary" id="closeRecordsBtn">Geri</button>
      </div>

      <div class="card" style="margin: 0 0 14px; background: rgba(255,255,255,0.12);">
        <h3 style="margin: 0 0 10px; color:#FFD700;">üë§ Tek Ki≈üi En ƒ∞yi Skorlar</h3>
        <div class="table-wrap">
          <table id="singleTable">
            <thead><tr><th>#</th><th>ƒ∞sim</th><th>Skor</th></tr></thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <div class="card" style="margin: 0 0 14px; background: rgba(255,255,255,0.12);">
        <h3 style="margin: 0 0 10px; color:#FFD700;">üë• D√ºello En ƒ∞yi Skorlar (Ki≈üi Bazlƒ±)</h3>
        <div class="table-wrap">
          <table id="duelTable">
            <thead><tr><th>#</th><th>ƒ∞sim</th><th>Skor</th></tr></thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <div class="card" style="margin: 0; background: rgba(255,255,255,0.12);">
        <h3 style="margin: 0 0 10px; color:#FFD700;">üìù Son D√ºellolar</h3>
        <div class="table-wrap">
          <table id="duelHistoryTable">
            <thead><tr><th>Tarih</th><th>1. Oyuncu</th><th>Skor</th><th>2. Oyuncu</th><th>Skor</th><th>Kazanan</th></tr></thead>
            <tbody></tbody>
          </table>
        </div>
        <p class="hint" style="margin-bottom: 0;">Not: Rekorlar bu cihazda saklanƒ±r (GitHub Pages i√ßin ideal).</p>
      </div>
    </section>
  </main>

  <script>
    // --- Veri seti ---
    const wordPairs = [
            {word: "Ev", correct: "Konut", options: ["Konut", "Bina", "Yapƒ±"]},
            {word: "Anƒ±", correct: "Hatƒ±ra", options: ["Hatƒ±ra", "Ge√ßmi≈ü", "Zaman"]},
            {word: "Nehir", correct: "Irmak", options: ["Irmak", "G√∂l", "Deniz"]},
            {word: "Kalp", correct: "Y√ºrek", options: ["Y√ºrek", "Akciƒüer", "Karaciƒüer"]},
            {word: "Okul", correct: "Mektep", options: ["Mektep", "Hastane", "Fabrika"]},
            {word: "Ki≈üi", correct: "≈ûahƒ±s", options: ["≈ûahƒ±s", "Nesne", "Hayvan"]},
            {word: "Islak", correct: "Ya≈ü", options: ["Ya≈ü", "Kuru", "Sƒ±cak"]},
            {word: "Surat", correct: "Y√ºz", options: ["Y√ºz", "Sa√ß", "Boyun"]},
            {word: "Sƒ±nƒ±f", correct: "Derslik", options: ["Derslik", "Koridor", "Bah√ße"]},
            {word: "Mekan", correct: "Yer", options: ["Yer", "Zaman", "Ki≈üi"]},
            {word: "Doƒüa", correct: "Tabiat", options: ["Tabiat", "≈ûehir", "Teknoloji"]},
            {word: "Kafa", correct: "Ba≈ü", options: ["Ba≈ü", "Ayak", "El"]},
            {word: "Sƒ±nav", correct: "ƒ∞mtihan", options: ["ƒ∞mtihan", "Oyun", "Tatil"]},
            {word: "Misafir", correct: "Konuk", options: ["Konuk", "Ev sahibi", "Kom≈üu"]},
            {word: "G√∂ky√ºz√º", correct: "Sema", options: ["Sema", "Toprak", "Deniz"]},
            {word: "D√º≈ü", correct: "R√ºya", options: ["R√ºya", "Ger√ßek", "Uyanƒ±klƒ±k"]},
            {word: "Alfabe", correct: "Abece", options: ["Abece", "Sayƒ±", "Resim"]},
            {word: "Kƒ±rmƒ±zƒ±", correct: "Al", options: ["Al", "Mavi", "Ye≈üil"]},
            {word: "Kƒ±ta", correct: "Anakara", options: ["Anakara", "Ada", "Yarƒ±mada"]},
            {word: "Ya≈üam", correct: "Hayat", options: ["Hayat", "√ñl√ºm", "Uyku"]},
            {word: "√ñƒürenci", correct: "Talebe", options: ["Talebe", "√ñƒüretmen", "M√ºd√ºr"]},
            {word: "Beyaz", correct: "Ak", options: ["Ak", "Siyah", "Gri"]},
            {word: "D√ºnya", correct: "Yerk√ºre", options: ["Yerk√ºre", "Ay", "G√ºne≈ü"]},
            {word: "Zaman", correct: "Vakit", options: ["Vakit", "Mekan", "Ki≈üi"]},
            {word: "√ñƒüretmen", correct: "Muallim", options: ["Muallim", "√ñƒürenci", "Veli"]},
            {word: "Siyah", correct: "Kara", options: ["Kara", "Beyaz", "Sarƒ±"]},
            {word: "R√ºzg√¢r", correct: "Yel", options: ["Yel", "Yaƒümur", "Kar"]},
            {word: "Yƒ±l", correct: "Sene", options: ["Sene", "Ay", "G√ºn"]},
            {word: "Doktor", correct: "Hekim", options: ["Hekim", "Hem≈üire", "Hasta"]},
            {word: "Soru", correct: "Sual", options: ["Sual", "Cevap", "Bilgi"]},
            {word: "Sonbahar", correct: "G√ºz", options: ["G√ºz", "ƒ∞lkbahar", "Yaz"]},
            {word: "Armaƒüan", correct: "Hediye", options: ["Hediye", "Bor√ß", "Alƒ±≈üveri≈ü"]},
            {word: "Esir", correct: "Tutsak", options: ["Tutsak", "√ñzg√ºr", "Kahraman"]},
            {word: "Veteriner", correct: "Baytar", options: ["Baytar", "Doktor", "Hem≈üire"]},
            {word: "Cevap", correct: "Yanƒ±t", options: ["Yanƒ±t", "Soru", "Problem"]},
            {word: "Tane", correct: "Adet", options: ["Adet", "Kilo", "Metre"]},
            {word: "Deprem", correct: "Zelzele", options: ["Zelzele", "Sel", "Yangƒ±n"]},
            {word: "Hakim", correct: "Yargƒ±√ß", options: ["Yargƒ±√ß", "Avukat", "Savcƒ±"]},
            {word: "Ne≈üe", correct: "Sevin√ß", options: ["Sevin√ß", "√úz√ºnt√º", "Korku"]},
            {word: "Yurt", correct: "Vatan", options: ["Vatan", "Otel", "Ev"]},
            {word: "B√ºy√ºk", correct: "ƒ∞ri", options: ["ƒ∞ri", "K√º√ß√ºk", "Orta"]},
            {word: "Kanun", correct: "Yasa", options: ["Yasa", "Su√ß", "Ceza"]},
            {word: "≈ûair", correct: "Ozan", options: ["Ozan", "Ressam", "M√ºzisyen"]},
            {word: "√ñyk√º", correct: "Hik√¢ye", options: ["Hik√¢ye", "≈ûiir", "Tiyatro"]},
            {word: "Macera", correct: "Ser√ºven", options: ["Ser√ºven", "Sƒ±kƒ±ntƒ±", "Rutin"]},
            {word: "√ñzlem", correct: "Hasret", options: ["Hasret", "Nefret", "Sevgi"]},
            {word: "Duygu", correct: "His", options: ["His", "D√º≈ü√ºnce", "Hareket"]},
            {word: "Uzak", correct: "Irak", options: ["Irak", "Yakƒ±n", "Orta"]},
            {word: "G√º√ß", correct: "Kuvvet", options: ["Kuvvet", "Zayƒ±flƒ±k", "Yorgunluk"]},
            {word: "Ulus", correct: "Millet", options: ["Millet", "≈ûehir", "K√∂y"]},
            {word: "Fakir", correct: "Yoksul", options: ["Yoksul", "Zengin", "Orta"]},
            {word: "Zengin", correct: "Varlƒ±klƒ±", options: ["Varlƒ±klƒ±", "Fakir", "Bor√ßlu"]},
            {word: "ƒ∞htiyar", correct: "Ya≈ülƒ±", options: ["Ya≈ülƒ±", "Gen√ß", "Orta"]},
            {word: "Davet", correct: "√áaƒürƒ±", options: ["√áaƒürƒ±", "Red", "Ka√ßƒ±≈ü"]},
            {word: "√ñnder", correct: "Lider", options: ["Lider", "Takip√ßi", "ƒ∞zleyici"]},
            {word: "Basit", correct: "Kolay", options: ["Kolay", "Zor", "Karma≈üƒ±k"]},
            {word: "Anlam", correct: "Mana", options: ["Mana", "≈ûekil", "Renk"]},
            {word: "Tanƒ±k", correct: "≈ûahit", options: ["≈ûahit", "Su√ßlu", "Hakim"]},
            {word: "Medeni", correct: "Uygar", options: ["Uygar", "Vah≈üi", "ƒ∞lkel"]},
            {word: "Yanlƒ±≈ü", correct: "Hata", options: ["Hata", "Doƒüru", "Kesin"]},
            {word: "ƒ∞sim", correct: "Ad", options: ["Ad", "Soyad", "Lakap"]},
            {word: "Nasihat", correct: "√ñƒü√ºt", options: ["√ñƒü√ºt", "Ele≈ütiri", "√ñvg√º"]},
            {word: "Devrim", correct: "ƒ∞nkƒ±lap", options: ["ƒ∞nkƒ±lap", "Sava≈ü", "Barƒ±≈ü"]},
            {word: "Dert", correct: "√úz√ºnt√º", options: ["√úz√ºnt√º", "Sevin√ß", "Mutluluk"]},
            {word: "Fiil", correct: "Eylem", options: ["Eylem", "ƒ∞sim", "Sƒ±fat"]},
            {word: "≈ûart", correct: "Ko≈üul", options: ["Ko≈üul", "Sonu√ß", "Sebep"]},
            {word: "Bulu≈ü", correct: "ƒ∞cat", options: ["ƒ∞cat", "Kayƒ±p", "Arama"]},
            {word: "√ñzg√ºrl√ºk", correct: "H√ºrriyet", options: ["H√ºrriyet", "Esaret", "Baƒüƒ±mlƒ±lƒ±k"]},
            {word: "ƒ∞lave", correct: "Ek", options: ["Ek", "Eksik", "Tam"]},
            {word: "Gƒ±da", correct: "Besin", options: ["Besin", "ƒ∞√ßecek", "ƒ∞la√ß"]},
            {word: "Fayda", correct: "Yarar", options: ["Yarar", "Zarar", "Kayƒ±p"]},
            {word: "Sebep", correct: "Neden", options: ["Neden", "Sonu√ß", "Etki"]},
            {word: "C√ºmle", correct: "T√ºmce", options: ["T√ºmce", "Kelime", "Harf"]},
            {word: "Kelime", correct: "S√∂zc√ºk", options: ["S√∂zc√ºk", "C√ºmle", "Paragraf"]},
            {word: "Kibar", correct: "Nazik", options: ["Nazik", "Kaba", "Sert"]},
            {word: "Eksik", correct: "Noksan", options: ["Noksan", "Tam", "Fazla"]},
            {word: "Hƒ±z", correct: "S√ºrat", options: ["S√ºrat", "Yava≈ülƒ±k", "Durgunluk"]},
            {word: "Zayƒ±f", correct: "Cƒ±lƒ±z", options: ["Cƒ±lƒ±z", "G√º√ßl√º", "Saƒülam"]},
            {word: "Saƒülƒ±k", correct: "Sƒ±hhat", options: ["Sƒ±hhat", "Hastalƒ±k", "Yorgunluk"]},
            {word: "Sava≈ü", correct: "Harp", options: ["Harp", "Barƒ±≈ü", "Dostluk"]},
            {word: "G√∂rev", correct: "Vazife", options: ["Vazife", "Hak", "ƒ∞zin"]},
            {word: "Acemi", correct: "Toy", options: ["Toy", "Deneyimli", "Usta"]},
            {word: "Gayret", correct: "√áaba", options: ["√áaba", "Tembellik", "Kaytarma"]},
            {word: "√ñneri", correct: "Teklif", options: ["Teklif", "Red", "Kabul"]},
            {word: "Egzersiz", correct: "Alƒ±≈ütƒ±rma", options: ["Alƒ±≈ütƒ±rma", "Dinlenme", "Uyku"]},
            {word: "Akƒ±llƒ±", correct: "Uslu", options: ["Uslu", "Aptal", "Dalgƒ±n"]},
            {word: "Ku≈üku", correct: "≈û√ºphe", options: ["≈û√ºphe", "Kesinlik", "ƒ∞nan√ß"]},
            {word: "Ama√ß", correct: "Hedef", options: ["Hedef", "Ba≈ülangƒ±√ß", "S√ºre√ß"]},
            {word: "Yetenek", correct: "Kabiliyet", options: ["Kabiliyet", "Yetersizlik", "Eksiklik"]},
            {word: "Problem", correct: "Sorun", options: ["Sorun", "√á√∂z√ºm", "Ba≈üarƒ±"]},
            {word: "Anƒ±t", correct: "Abide", options: ["Abide", "Ev", "D√ºkk√¢n"]},
            {word: "Az", correct: "Kƒ±t", options: ["Kƒ±t", "√áok", "Bol"]},
            {word: "Bi√ßim", correct: "≈ûekil", options: ["≈ûekil", "Renk", "Boyut"]},
            {word: "Ba≈üvuru", correct: "M√ºracaat", options: ["M√ºracaat", "Red", "Vazge√ßme"]},
            {word: "Uyarƒ±", correct: "ƒ∞kaz", options: ["ƒ∞kaz", "√ñvg√º", "Te≈üekk√ºr"]},
            {word: "Yemek", correct: "A≈ü", options: ["A≈ü", "ƒ∞√ßecek", "Tatlƒ±"]},
            {word: "≈ûehir", correct: "Kent", options: ["Kent", "K√∂y", "Kasaba"]},
            {word: "Asƒ±r", correct: "Y√ºzyƒ±l", options: ["Y√ºzyƒ±l", "Yƒ±l", "Ay"]},
            {word: "Konut", correct: "Ev", options: ["Ev", "D√ºkk√¢n", "Fabrika"]},
            {word: "Hatƒ±ra", correct: "Anƒ±", options: ["Anƒ±", "Gelecek", "≈ûimdi"]},
            {word: "Irmak", correct: "Nehir", options: ["Nehir", "G√∂l", "Deniz"]},
            {word: "Y√ºrek", correct: "Kalp", options: ["Kalp", "Akciƒüer", "Mide"]},
            {word: "Mektep", correct: "Okul", options: ["Okul", "Hastane", "Market"]},
            {word: "≈ûahƒ±s", correct: "Ki≈üi", options: ["Ki≈üi", "E≈üya", "Hayvan"]},
            {word: "Ya≈ü", correct: "Islak", options: ["Islak", "Kuru", "Sert"]},
            {word: "Y√ºz", correct: "Surat", options: ["Surat", "Sa√ß", "G√∂z"]},
            {word: "Derslik", correct: "Sƒ±nƒ±f", options: ["Sƒ±nƒ±f", "Koridor", "Kantin"]},
            {word: "Yer", correct: "Mekan", options: ["Mekan", "Zaman", "Sebep"]},
            {word: "Tabiat", correct: "Doƒüa", options: ["Doƒüa", "Teknoloji", "Sanat"]},
            {word: "Ba≈ü", correct: "Kafa", options: ["Kafa", "Ayak", "Kol"]},
            {word: "ƒ∞mtihan", correct: "Sƒ±nav", options: ["Sƒ±nav", "Tatil", "Oyun"]},
            {word: "Konuk", correct: "Misafir", options: ["Misafir", "Ev sahibi", "Kapƒ±cƒ±"]},
            {word: "Sema", correct: "G√∂ky√ºz√º", options: ["G√∂ky√ºz√º", "Yeraltƒ±", "Deniz"]},
            {word: "R√ºya", correct: "D√º≈ü", options: ["D√º≈ü", "Ger√ßek", "Hatƒ±ra"]},
            {word: "Abece", correct: "Alfabe", options: ["Alfabe", "Rakam", "Nota"]},
            {word: "Al", correct: "Kƒ±rmƒ±zƒ±", options: ["Kƒ±rmƒ±zƒ±", "Mavi", "Sarƒ±"]},
            {word: "Anakara", correct: "Kƒ±ta", options: ["Kƒ±ta", "Ada", "K√∂pr√º"]},
            {word: "Hayat", correct: "Ya≈üam", options: ["Ya≈üam", "√ñl√ºm", "Hastalƒ±k"]},
            {word: "Talebe", correct: "√ñƒürenci", options: ["√ñƒürenci", "√ñƒüretmen", "M√ºd√ºr"]},
            {word: "Ak", correct: "Beyaz", options: ["Beyaz", "Siyah", "Kƒ±rmƒ±zƒ±"]},
            {word: "Yerk√ºre", correct: "D√ºnya", options: ["D√ºnya", "Mars", "Ven√ºs"]},
            {word: "Vakit", correct: "Zaman", options: ["Zaman", "Yer", "Ki≈üi"]},
            {word: "Muallim", correct: "√ñƒüretmen", options: ["√ñƒüretmen", "√ñƒürenci", "M√ºd√ºr"]},
            {word: "Kara", correct: "Siyah", options: ["Siyah", "Beyaz", "Gri"]},
            {word: "Yel", correct: "R√ºzg√¢r", options: ["R√ºzg√¢r", "Yaƒümur", "G√ºne≈ü"]},
            {word: "Sene", correct: "Yƒ±l", options: ["Yƒ±l", "Ay", "Hafta"]},
            {word: "Hekim", correct: "Doktor", options: ["Doktor", "Hasta", "Ebe"]},
            {word: "Sual", correct: "Soru", options: ["Soru", "Cevap", "A√ßƒ±klama"]},
            {word: "G√ºz", correct: "Sonbahar", options: ["Sonbahar", "ƒ∞lkbahar", "Kƒ±≈ü"]},
            {word: "Hediye", correct: "Armaƒüan", options: ["Armaƒüan", "Satƒ±≈ü", "Kiralama"]},
            {word: "Tutsak", correct: "Esir", options: ["Esir", "√ñzg√ºr", "Ka√ßak"]},
            {word: "Baytar", correct: "Veteriner", options: ["Veteriner", "Doktor", "Di≈ü hekimi"]},
            {word: "Yanƒ±t", correct: "Cevap", options: ["Cevap", "Soru", "Bilmece"]},
            {word: "Adet", correct: "Tane", options: ["Tane", "Kilo", "Litre"]},
            {word: "Zelzele", correct: "Deprem", options: ["Deprem", "Sel", "Heyelan"]},
            {word: "Yargƒ±√ß", correct: "Hakim", options: ["Hakim", "Avukat", "Polis"]},
            {word: "Sevin√ß", correct: "Ne≈üe", options: ["Ne≈üe", "Keder", "√ñfke"]},
            {word: "Vatan", correct: "Yurt", options: ["Yurt", "Otel", "Pansiyon"]},
            {word: "ƒ∞ri", correct: "B√ºy√ºk", options: ["B√ºy√ºk", "K√º√ß√ºk", "Ufak"]},
            {word: "Yasa", correct: "Kanun", options: ["Kanun", "Su√ß", "Hak"]},
            {word: "Ozan", correct: "≈ûair", options: ["≈ûair", "Yazar", "√áizer"]},
            {word: "Hik√¢ye", correct: "√ñyk√º", options: ["√ñyk√º", "Roman", "≈ûiir"]},
            {word: "Ser√ºven", correct: "Macera", options: ["Macera", "Sƒ±kƒ±ntƒ±", "Monotonluk"]},
            {word: "Hasret", correct: "√ñzlem", options: ["√ñzlem", "Nefret", "Kayƒ±tsƒ±zlƒ±k"]},
            {word: "His", correct: "Duygu", options: ["Duygu", "D√º≈ü√ºnce", "Bilgi"]},
            {word: "Irak", correct: "Uzak", options: ["Uzak", "Yakƒ±n", "Biti≈üik"]},
            {word: "Kuvvet", correct: "G√º√ß", options: ["G√º√ß", "Zayƒ±flƒ±k", "Hastalƒ±k"]},
            {word: "Millet", correct: "Ulus", options: ["Ulus", "Aile", "Grup"]},
            {word: "Yoksul", correct: "Fakir", options: ["Fakir", "Zengin", "Varlƒ±klƒ±"]},
            {word: "Varlƒ±klƒ±", correct: "Zengin", options: ["Zengin", "Fakir", "Yoksul"]},
            {word: "Ya≈ülƒ±", correct: "ƒ∞htiyar", options: ["ƒ∞htiyar", "Gen√ß", "√áocuk"]},
            {word: "√áaƒürƒ±", correct: "Davet", options: ["Davet", "Red", "Ka√ßƒ±≈ü"]},
            {word: "Lider", correct: "√ñnder", options: ["√ñnder", "Takip√ßi", "√úye"]},
            {word: "Kolay", correct: "Basit", options: ["Basit", "Zor", "Karƒ±≈üƒ±k"]},
            {word: "Mana", correct: "Anlam", options: ["Anlam", "G√∂r√ºn√º≈ü", "Ses"]},
            {word: "≈ûahit", correct: "Tanƒ±k", options: ["Tanƒ±k", "Su√ßlu", "Maƒüdur"]},
            {word: "Uygar", correct: "Medeni", options: ["Medeni", "Vah≈üi", "Barbar"]},
            {word: "Hata", correct: "Yanlƒ±≈ü", options: ["Yanlƒ±≈ü", "Doƒüru", "Kesin"]},
            {word: "Ad", correct: "ƒ∞sim", options: ["ƒ∞sim", "Soyad", "Unvan"]},
            {word: "√ñƒü√ºt", correct: "Nasihat", options: ["Nasihat", "Azarlama", "√ñvg√º"]},
            {word: "ƒ∞nkƒ±lap", correct: "Devrim", options: ["Devrim", "Gericilik", "Durgunluk"]},
            {word: "√úz√ºnt√º", correct: "Dert", options: ["Dert", "Sevin√ß", "Heyecan"]},
            {word: "Eylem", correct: "Fiil", options: ["Fiil", "ƒ∞sim", "Zarf"]},
            {word: "Ko≈üul", correct: "≈ûart", options: ["≈ûart", "Sonu√ß", "Neden"]},
            {word: "ƒ∞cat", correct: "Bulu≈ü", options: ["Bulu≈ü", "Kayƒ±p", "Kopya"]},
            {word: "H√ºrriyet", correct: "√ñzg√ºrl√ºk", options: ["√ñzg√ºrl√ºk", "K√∂lelik", "Baƒüƒ±mlƒ±lƒ±k"]},
            {word: "Ek", correct: "ƒ∞lave", options: ["ƒ∞lave", "√áƒ±karma", "Azaltma"]},
            {word: "Besin", correct: "Gƒ±da", options: ["Gƒ±da", "Zehir", "ƒ∞la√ß"]},
            {word: "Yarar", correct: "Fayda", options: ["Fayda", "Zarar", "Ziyan"]},
            {word: "Neden", correct: "Sebep", options: ["Sebep", "Sonu√ß", "Ama√ß"]},
            {word: "T√ºmce", correct: "C√ºmle", options: ["C√ºmle", "Kelime", "Paragraf"]},
            {word: "S√∂zc√ºk", correct: "Kelime", options: ["Kelime", "Harf", "Sayƒ±"]},
            {word: "Nazik", correct: "Kibar", options: ["Kibar", "Kaba", "Saldƒ±rgan"]},
            {word: "Noksan", correct: "Eksik", options: ["Eksik", "Tam", "Fazla"]},
            {word: "S√ºrat", correct: "Hƒ±z", options: ["Hƒ±z", "Yava≈ülƒ±k", "Durma"]},
            {word: "Cƒ±lƒ±z", correct: "Zayƒ±f", options: ["Zayƒ±f", "G√º√ßl√º", "Saƒülam"]},
            {word: "Sƒ±hhat", correct: "Saƒülƒ±k", options: ["Saƒülƒ±k", "Hastalƒ±k", "Sakatlƒ±k"]},
            {word: "Harp", correct: "Sava≈ü", options: ["Sava≈ü", "Barƒ±≈ü", "Anla≈üma"]},
            {word: "Vazife", correct: "G√∂rev", options: ["G√∂rev", "Hak", "√ñzg√ºrl√ºk"]},
            {word: "Toy", correct: "Acemi", options: ["Acemi", "Usta", "Deneyimli"]},
            {word: "√áaba", correct: "Gayret", options: ["Gayret", "Tembellik", "ƒ∞hmal"]},
            {word: "Teklif", correct: "√ñneri", options: ["√ñneri", "Red", "Kabul"]},
            {word: "Alƒ±≈ütƒ±rma", correct: "Egzersiz", options: ["Egzersiz", "Dinlenme", "Tembellik"]},
            {word: "Uslu", correct: "Akƒ±llƒ±", options: ["Akƒ±llƒ±", "Aptal", "Cahil"]},
            {word: "≈û√ºphe", correct: "Ku≈üku", options: ["Ku≈üku", "Kesinlik", "G√ºven"]},
            {word: "Hedef", correct: "Ama√ß", options: ["Ama√ß", "Ba≈ülangƒ±√ß", "S√ºre√ß"]},
            {word: "Kabiliyet", correct: "Yetenek", options: ["Yetenek", "Beceriksizlik", "Yetersizlik"]},
            {word: "Sorun", correct: "Problem", options: ["Problem", "√á√∂z√ºm", "Ba≈üarƒ±"]},
            {word: "Abide", correct: "Anƒ±t", options: ["Anƒ±t", "Ev", "Maƒüaza"]},
            {word: "Kƒ±t", correct: "Az", options: ["Az", "√áok", "Fazla"]},
            {word: "≈ûekil", correct: "Bi√ßim", options: ["Bi√ßim", "Renk", "Aƒüƒ±rlƒ±k"]},
            {word: "M√ºracaat", correct: "Ba≈üvuru", options: ["Ba≈üvuru", "Vazge√ßme", "Ka√ßƒ±≈ü"]},
            {word: "ƒ∞kaz", correct: "Uyarƒ±", options: ["Uyarƒ±", "√ñvg√º", "Takdir"]},
            {word: "A≈ü", correct: "Yemek", options: ["Yemek", "Su", "Hava"]},
            {word: "Kent", correct: "≈ûehir", options: ["≈ûehir", "K√∂y", "Orman"]},
            {word: "Y√ºzyƒ±l", correct: "Asƒ±r", options: ["Asƒ±r", "Yƒ±l", "G√ºn"]}
        ];

    // --- Oyun ayarlarƒ± ---
    const GAME_SECONDS = 60;
    const CORRECT_POINTS = 10;
    const WRONG_POINTS = 5;
    const WRONG_TIME_PENALTY = 3;

    // --- Storage ---
    const STORAGE_KEY = "synonymGameRecords_v1";
    function loadRecords() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return { single: {}, duel: {}, duelHistory: [] };
        const parsed = JSON.parse(raw);
        return {
          single: parsed.single || {},
          duel: parsed.duel || {},
          duelHistory: Array.isArray(parsed.duelHistory) ? parsed.duelHistory : []
        };
      } catch (e) {
        return { single: {}, duel: {}, duelHistory: [] };
      }
    }
    function saveRecords(records) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(records));
    }

    // --- UI refs ---
    const homeSection = document.getElementById("homeSection");
    const gameSection = document.getElementById("gameSection");
    const resultSection = document.getElementById("resultSection");
    const recordsSection = document.getElementById("recordsSection");

    const modeSingleBtn = document.getElementById("modeSingleBtn");
    const modeDuelBtn = document.getElementById("modeDuelBtn");
    const singleInputsRow = document.getElementById("singleInputsRow");
    const duelInputsRow = document.getElementById("duelInputsRow");

    const singleName = document.getElementById("singleName");
    const duelName1 = document.getElementById("duelName1");
    const duelName2 = document.getElementById("duelName2");

    const startGameBtn = document.getElementById("startGameBtn");
    const backToMenuBtn = document.getElementById("backToMenuBtn");
    const playAgainBtn = document.getElementById("playAgainBtn");
    const menuBtnFromResult = document.getElementById("menuBtnFromResult");
    const recordsBtnFromResult = document.getElementById("recordsBtnFromResult");
    const openRecordsBtn = document.getElementById("openRecordsBtn");
    const openRecordsBtn2 = document.getElementById("openRecordsBtn2");
    const closeRecordsBtn = document.getElementById("closeRecordsBtn");

    const timerEl = document.getElementById("timer");
    const contestantsArea = document.getElementById("contestantsArea");
    const progressContainer = document.getElementById("progressContainer");

    const resultMainScore = document.getElementById("resultMainScore");
    const resultMini = document.getElementById("resultMini");
    const resultGrid = document.getElementById("resultGrid");

    const singleTableBody = document.querySelector("#singleTable tbody");
    const duelTableBody = document.querySelector("#duelTable tbody");
    const duelHistoryBody = document.querySelector("#duelHistoryTable tbody");

    // --- State ---
    let currentSection = homeSection;
    let lastNonRecordsSection = homeSection;

    let mode = "single"; // "single" | "duel"
    let players = [];
    let scores = {};
    let currentQuestions = {};
    let decks = {};
    let deckPos = {};
    let lastIdx = {};

    let timeLeft = GAME_SECONDS;
    let gameActive = false;
    let timerHandle = null;

    // --- Helpers ---
    function normalizeName(name) {
      return (name || "").trim().replace(/\s+/g, " ").slice(0, 24);
    }

    function shuffleArray(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function ensureDeck(player) {
      if (!decks[player] || deckPos[player] >= decks[player].length) {
        decks[player] = shuffleArray([...Array(wordPairs.length).keys()]);
        deckPos[player] = 0;
      }
    }

    function nextWordIndex(player) {
      ensureDeck(player);
      // "Tam rastgele" hissi: aynƒ± soruyu art arda getirmemeye √ßalƒ±≈ü
      let idx = decks[player][deckPos[player]++];
      if (lastIdx[player] !== undefined && idx === lastIdx[player] && wordPairs.length > 1) {
        // bir sonrakiyle deƒüi≈ütir (varsa)
        ensureDeck(player);
        if (deckPos[player] < decks[player].length) {
          const idx2 = decks[player][deckPos[player]++];
          idx = idx2;
        } else {
          // son anda geldiyse tekrar karƒ±≈ütƒ±r
          decks[player] = shuffleArray([...Array(wordPairs.length).keys()]);
          deckPos[player] = 0;
          idx = decks[player][deckPos[player]++];
        }
      }
      lastIdx[player] = idx;
      return idx;
    }

    function showOnly(section) {
      homeSection.classList.add("hidden");
      gameSection.classList.add("hidden");
      resultSection.classList.add("hidden");
      recordsSection.classList.add("hidden");
      section.classList.remove("hidden");
      currentSection = section;
      if (section !== recordsSection) lastNonRecordsSection = section;
    }

    function setMode(newMode) {
      mode = newMode;
      if (mode === "single") {
        modeSingleBtn.classList.add("selected");
        modeDuelBtn.classList.remove("selected");
        singleInputsRow.classList.remove("hidden");
        duelInputsRow.classList.add("hidden");
      } else {
        modeDuelBtn.classList.add("selected");
        modeSingleBtn.classList.remove("selected");
        duelInputsRow.classList.remove("hidden");
        singleInputsRow.classList.add("hidden");
      }
    }

    // --- Sounds (same idea as old file) ---
    function playCorrectSound() {
      try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        oscillator.connect(gainNode); gainNode.connect(audioContext.destination);
        oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime);
        oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1);
        oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2);
        gainNode.gain.setValueAtTime(0.28, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
        oscillator.type = 'sine';
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.3);
      } catch (e) {}
    }
    function playIncorrectSound() {
      try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        oscillator.connect(gainNode); gainNode.connect(audioContext.destination);
        oscillator.frequency.setValueAtTime(349.23, audioContext.currentTime);
        oscillator.frequency.setValueAtTime(293.66, audioContext.currentTime + 0.1);
        oscillator.frequency.setValueAtTime(246.94, audioContext.currentTime + 0.2);
        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
        oscillator.type = 'triangle';
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.4);
      } catch (e) {}
    }

    // --- Rendering ---
    function renderPlayers() {
      contestantsArea.innerHTML = "";
      contestantsArea.className = "contestants-area " + (players.length === 2 ? "two-columns" : "one-column");

      players.forEach((p, i) => {
        const div = document.createElement("div");
        div.className = "contestant " + (i === 0 ? "player1" : "player2");
        div.innerHTML = `
          <div class="contestant-name">${escapeHtml(p)}</div>
          <div class="score" id="score-${cssSafe(p)}">0</div>
          <div class="question-area">
            <div class="question" id="question-${cssSafe(p)}">Hazƒ±rlanƒ±yor...</div>
            <div class="options" id="options-${cssSafe(p)}"></div>
          </div>
        `;
        contestantsArea.appendChild(div);
      });
    }

    function cssSafe(name) {
      // ids: Turkish letters are ok in HTML ids but we keep it safe
      return name.replace(/[^a-zA-Z0-9_-]/g, "_");
    }

    function escapeHtml(str) {
      return (str || "").replace(/[&<>"]/g, (c) => ({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;"}[c]));
    }

    function updateScoreUI(player) {
      const id = "score-" + cssSafe(player);
      const el = document.getElementById(id);
      if (el) el.textContent = scores[player] || 0;
    }

    function updateProgressBar() {
      progressContainer.innerHTML = "";
      const colors = ["#FF8C00", "#1E90FF"];
      const total = Object.values(scores).reduce((s, v) => s + Math.max(0, v), 0);

      if (players.length === 0) return;

      if (total <= 0) {
        players.forEach((p, idx) => {
          const seg = document.createElement("div");
          seg.className = "progress-segment " + (players.length === 1 ? "single" : "");
          seg.style.width = (100 / players.length) + "%";
          seg.style.background = colors[idx] || "#32CD32";
          progressContainer.appendChild(seg);
        });
      } else {
        players.forEach((p, idx) => {
          const seg = document.createElement("div");
          seg.className = "progress-segment " + (players.length === 1 ? "single" : "");
          const val = Math.max(0, scores[p] || 0);
          seg.style.width = ((val / total) * 100) + "%";
          seg.style.background = colors[idx] || "#32CD32";
          progressContainer.appendChild(seg);
        });
      }
    }

    function renderQuestion(player) {
      const idx = nextWordIndex(player);
      const q = wordPairs[idx];
      currentQuestions[player] = q;

      const qEl = document.getElementById("question-" + cssSafe(player));
      const optEl = document.getElementById("options-" + cssSafe(player));
      if (!qEl || !optEl) return;

      qEl.textContent = q.word;
      optEl.innerHTML = "";

      const options = shuffleArray([...q.options]);
      options.forEach((opt) => {
        const btn = document.createElement("button");
        btn.className = "option-btn";
        btn.textContent = opt;
        btn.addEventListener("click", () => onAnswer(player, opt));
        optEl.appendChild(btn);
      });
    }

    function disableOptions(player) {
      const optEl = document.getElementById("options-" + cssSafe(player));
      if (!optEl) return [];
      const buttons = Array.from(optEl.querySelectorAll(".option-btn"));
      buttons.forEach(b => b.style.pointerEvents = "none");
      return buttons;
    }

    function onAnswer(player, selected) {
      if (!gameActive) return;

      const q = currentQuestions[player];
      if (!q) return;

      const buttons = disableOptions(player);
      buttons.forEach((btn) => {
        if (btn.textContent === q.correct) btn.classList.add("correct");
        else if (btn.textContent === selected) btn.classList.add("wrong");
      });

      const correct = selected === q.correct;

      if (correct) {
        playCorrectSound();
        scores[player] = (scores[player] || 0) + CORRECT_POINTS;
      } else {
        playIncorrectSound();
        scores[player] = (scores[player] || 0) - WRONG_POINTS;
        timeLeft = Math.max(0, timeLeft - WRONG_TIME_PENALTY);
        timerEl.textContent = timeLeft;
        if (timeLeft <= 0) {
          endGame();
          return;
        }
      }

      updateScoreUI(player);
      updateProgressBar();

      setTimeout(() => {
        if (gameActive) renderQuestion(player);
      }, 650);
    }

    function startGameWithPlayers(newPlayers) {
      players = newPlayers;
      scores = {};
      currentQuestions = {};
      decks = {};
      deckPos = {};
      lastIdx = {};

      players.forEach(p => scores[p] = 0);

      timeLeft = GAME_SECONDS;
      timerEl.textContent = timeLeft;

      renderPlayers();
      updateProgressBar();

      players.forEach(p => renderQuestion(p));

      showOnly(gameSection);
      gameActive = true;

      if (timerHandle) clearInterval(timerHandle);
      timerHandle = setInterval(() => {
        timeLeft--;
        timerEl.textContent = timeLeft;
        if (timeLeft <= 0) endGame();
      }, 1000);
    }

    function endGame() {
      if (!gameActive) return;
      gameActive = false;
      if (timerHandle) clearInterval(timerHandle);

      // Save records
      const rec = loadRecords();
      if (players.length === 1) {
        const name = players[0];
        const pts = scores[name] || 0;
        rec.single[name] = Math.max(rec.single[name] || 0, pts);
      } else if (players.length === 2) {
        const p1 = players[0], p2 = players[1];
        const s1 = scores[p1] || 0, s2 = scores[p2] || 0;
        rec.duel[p1] = Math.max(rec.duel[p1] || 0, s1);
        rec.duel[p2] = Math.max(rec.duel[p2] || 0, s2);

        const winner = (s1 === s2) ? "Berabere" : (s1 > s2 ? p1 : p2);
        rec.duelHistory.unshift({
          date: new Date().toISOString(),
          p1, p2, s1, s2, winner
        });
        rec.duelHistory = rec.duelHistory.slice(0, 15);
      }
      saveRecords(rec);

      renderResult();
      showOnly(resultSection);
    }

    function renderResult() {
      resultGrid.innerHTML = "";
      if (players.length === 1) {
        const p = players[0];
        const pts = scores[p] || 0;
        resultMainScore.textContent = pts + " Puan";
        resultMini.textContent = `${p} i√ßin skor kaydedildi ‚úÖ`;
      } else {
        // headline: winner + scores
        const p1 = players[0], p2 = players[1];
        const s1 = scores[p1] || 0, s2 = scores[p2] || 0;
        let headline = "Berabere! ‚öñÔ∏è";
        if (s1 > s2) headline = `${p1} Kazandƒ±! üèÜ`;
        else if (s2 > s1) headline = `${p2} Kazandƒ±! üèÜ`;
        resultMainScore.textContent = headline;
        resultMini.textContent = "Skorlar kaydedildi ‚úÖ";

        const grid = document.createElement("div");
        grid.className = "result-grid two-columns";

        const c1 = document.createElement("div");
        c1.className = "result-card";
        c1.innerHTML = `<div class="name">${escapeHtml(p1)}</div><div class="pts">${s1}</div><div>Puan</div>`;

        const c2 = document.createElement("div");
        c2.className = "result-card";
        c2.innerHTML = `<div class="name">${escapeHtml(p2)}</div><div class="pts">${s2}</div><div>Puan</div>`;

        grid.appendChild(c1);
        grid.appendChild(c2);
        resultGrid.appendChild(grid);
        return;
      }
    }

    function renderRecords() {
      const rec = loadRecords();

      // single
      const singleEntries = Object.entries(rec.single).sort((a,b) => b[1]-a[1]).slice(0, 10);
      singleTableBody.innerHTML = "";
      if (singleEntries.length === 0) {
        singleTableBody.innerHTML = `<tr><td colspan="3">Hen√ºz kayƒ±t yok.</td></tr>`;
      } else {
        singleEntries.forEach(([name, pts], i) => {
          singleTableBody.innerHTML += `<tr><td>${i+1}</td><td>${escapeHtml(name)}</td><td><b>${pts}</b></td></tr>`;
        });
      }

      // duel person-best
      const duelEntries = Object.entries(rec.duel).sort((a,b) => b[1]-a[1]).slice(0, 10);
      duelTableBody.innerHTML = "";
      if (duelEntries.length === 0) {
        duelTableBody.innerHTML = `<tr><td colspan="3">Hen√ºz kayƒ±t yok.</td></tr>`;
      } else {
        duelEntries.forEach(([name, pts], i) => {
          duelTableBody.innerHTML += `<tr><td>${i+1}</td><td>${escapeHtml(name)}</td><td><b>${pts}</b></td></tr>`;
        });
      }

      // duel history
      duelHistoryBody.innerHTML = "";
      const hist = rec.duelHistory || [];
      if (hist.length === 0) {
        duelHistoryBody.innerHTML = `<tr><td colspan="6">Hen√ºz d√ºello yok.</td></tr>`;
      } else {
        hist.slice(0, 12).forEach(item => {
          const d = new Date(item.date);
          const dateStr = isNaN(d.getTime()) ? "-" : d.toLocaleString("tr-TR", { dateStyle:"short", timeStyle:"short" });
          duelHistoryBody.innerHTML += `
            <tr>
              <td>${escapeHtml(dateStr)}</td>
              <td>${escapeHtml(item.p1)}</td>
              <td><b>${item.s1}</b></td>
              <td>${escapeHtml(item.p2)}</td>
              <td><b>${item.s2}</b></td>
              <td>${escapeHtml(item.winner)}</td>
            </tr>
          `;
        });
      }
    }

    // --- Events ---
    modeSingleBtn.addEventListener("click", () => setMode("single"));
    modeDuelBtn.addEventListener("click", () => setMode("duel"));

    startGameBtn.addEventListener("click", () => {
      if (mode === "single") {
        const n = normalizeName(singleName.value);
        if (!n) { alert("L√ºtfen ismini yaz üôÇ"); singleName.focus(); return; }
        startGameWithPlayers([n]);
      } else {
        const n1 = normalizeName(duelName1.value);
        const n2 = normalizeName(duelName2.value);
        if (!n1 || !n2) { alert("L√ºtfen iki ismi de yaz üôÇ"); if (!n1) duelName1.focus(); else duelName2.focus(); return; }
        if (n1.toLowerCase() === n2.toLowerCase()) { alert("ƒ∞ki oyuncunun ismi farklƒ± olmalƒ± üôÇ"); duelName2.focus(); return; }
        startGameWithPlayers([n1, n2]);
      }
    });

    backToMenuBtn.addEventListener("click", () => {
      if (timerHandle) clearInterval(timerHandle);
      gameActive = false;
      showOnly(homeSection);
    });

    playAgainBtn.addEventListener("click", () => {
      // same mode & same names
      if (players.length === 1) startGameWithPlayers([players[0]]);
      else startGameWithPlayers([players[0], players[1]]);
    });

    menuBtnFromResult.addEventListener("click", () => showOnly(homeSection));
    recordsBtnFromResult.addEventListener("click", () => openRecords());
    openRecordsBtn.addEventListener("click", () => openRecords());
    openRecordsBtn2.addEventListener("click", () => openRecords());

    function openRecords() {
      // remember where we came from
      lastNonRecordsSection = currentSection || homeSection;
      renderRecords();
      showOnly(recordsSection);
    }

    closeRecordsBtn.addEventListener("click", () => {
      showOnly(lastNonRecordsSection || homeSection);
    });

    // Initial
    setMode("single");
  </script>
</body>
</html>
